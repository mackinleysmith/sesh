#!/usr/bin/env ruby
require 'tmuxinator'

if ARGV.empty? or ARGV.include? '-h' or ARGV.include? '--help' then puts <<-HELP
Sesh: remote background sessions powered by tmux and tmuxinator.
Runs a headless tmuxinator session for remote slave machines to connect to.

Usage: #{File.basename $0} command [project]

Commands:

sesh new                           Create a new tmuxinator configuration.
sesh edit    [project]             Edit an existing tmuxinator configuration.
sesh start   [project]             Start a Sesh session for a project.
sesh stop    [project]             Stop a Sesh session for a project.
sesh list                          List running Sesh sessions on this machine.
sesh enslave [project] user@host   Connect a slave to a local Sesh session.
sesh connect [project] [user@host] Connect as a slave to a Sesh session.

Leave project blank to use the name of your current directory.

HELP
exit; end

def warn(msg) $stderr.puts msg end
def fatal(msg) $stderr.puts msg; $stderr.puts; exit 1 end
def debug(msg) $stderr.puts "> #{msg}" end

@command = ARGV[0]
@options = ARGV[1..-1] || []
# debug("Options received: #{@options}") if @options.any?

def get_local_username
  `echo $USER`.strip
end
def get_local_hostname
  `scutil --get LocalHostName`.strip.downcase + '.local'
end
@local_ssh_addr = "#{get_local_username}@#{get_local_hostname}"

def get_project_name
  return if @command == 'list'
  new_project = @command == 'new'
  remote_project = @command == 'connect' && @options.select{|o| o.include? '@' }.any?
  if @options.any? && !@options[0].include?('@')
    return @options.shift if new_project || remote_project || 
                             Tmuxinator::Config.exists?(@options[0])
  end
  output = `printf '%q\n' "${PWD##*/}"`.strip
  return output if new_project || Tmuxinator::Config.exists?(output)
  puts "Sesh project '#{output}' could not be found."
  fatal "Hint: run sesh new or specify an existing project after your commmand."
end
@project_name = get_project_name


@socket_file = "/tmp/#{@project_name}.sock"
@pids_file   = "/tmp/#{@project_name}.pids.txt"

def get_remote_address
  @options[@options.length>1 ? 1:0] if @options.any?
end
@remote_address = get_remote_address

def get_term_app
  output = `osascript -e 'try' -e 'get exists application "iTerm"' -e 'end try'`.strip
  output.length > 0 ? 'iTerm' : fatal("iTerm 2 is not installed.") # 'Terminal'
end

def get_editor
  editor = `echo $EDITOR`.strip
  editor = 'vim' unless editor.length > 0
  editor
end

def project_name_matcher
  pn = @project_name.gsub '-', '\-'
  "[t]mux.*[#{pn[0]}]#{pn[1..-1]}"
end

def already_running?
  output = `ps aux | grep "#{project_name_matcher}"`.strip
  output.length > 0
end

def format_command(command) command.gsub(/\ [ ]+/, ' ').strip end
def format_and_run_command(command) `#{format_command(command)}`.strip end

def issue_server_start_command!
  `tmux -S "#{@socket_file}" new-session -d "env TMUX='' mux start #{@project_name}"`
end

def issue_server_stop_command!
  `pkill -f "#{project_name_matcher}"`
end

def connection_command(local=false, addr=nil)
  addr ||= @local_ssh_addr
  local_command = "tmux -S #{@socket_file} a"
  return local_command if local
  "ssh #{addr} -t '#{local_command}'"
end

def enter_slave_mode_command(local=false, addr=nil)
  @term_app ||= get_term_app
  case @term_app
  when 'iTerm'
    tell_term_app     = 'tell application "' + @term_app + '"'
    tell_term_process = 'tell application "System Events" to tell process "' + 
                         @term_app + '"'
    format_command <<-BASH
      osascript \
            -e '#{tell_term_app} to activate' \
            -e '#{tell_term_process} to keystroke \"n\" using command down' \
            -e 'delay 1' \
            -e "#{tell_term_app.gsub('"', '\\"')} to tell session -1 of current \
                terminal to write text \\"#{connection_command(local, addr)}\\"" \
            -e '#{tell_term_process} to keystroke return using command down'
    BASH
  when 'Terminal'
    format_command connection_command(local, addr)
  end
end

def show_progress_until(condition_lambda, timeout=10)
  started_progress_at = Time.now
  return true if condition_lambda.call
  print '> '
  until condition_lambda.call or Time.now - started_progress_at > timeout
    print '.'
    $stdout.flush
    sleep 0.5 
  end
  puts
  return condition_lambda.call
end

def kill_running_processes
  if File.exists? @pids_file
    File.readlines(@pids_file).each{|pid| kill_process! pid }
    File.delete @pids_file
  end
end
def kill_process!(pid)
  `kill -9 #{pid}`
end

if @command
  case @command
  when 'start'
    fatal("Sesh project '#{@project_name}' is already running!") if already_running?
    debug "Starting Sesh project '#{@project_name}'..."
    kill_running_processes
    output = issue_server_start_command!
    success = show_progress_until ->{ already_running? }
    if success
      sleep 1
      if $? && already_running?
        pids = `tmux list-panes -s -F "\#{pane_pid} \#{pane_current_command}" | grep -v tmux | awk '{print $1}'`.strip.lines
        File.open(@pids_file, 'w') {|f| pids.each{|pid| f.puts pid } }
        debug 'Sesh started successfully.'
        debug "To connect: #{connection_command}"
        # TODO: show other sesh commands (connect, enslave), specify full
        #       command as what is needed for machines without sesh.
        puts
      else
        fatal 'Sesh failed to start!'
      end
    else
      fatal 'Sesh failed to start after ten seconds!'
    end
  when 'stop'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    debug "Stopping Sesh project '#{@project_name}'..."
    kill_running_processes
    output = issue_server_stop_command!
    success = show_progress_until ->{ !already_running? }
    if success && $?
      debug 'Sesh stopped successfully.'
      puts
    else
      fatal 'Sesh failed to stop after ten seconds!'
    end
  when 'restart'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    puts `sesh stop #{@project_name} #{@options if @options.any?}`.strip
    sleep(0.5)
    puts `sesh start #{@project_name} #{@options if @options.any?}`.strip
  when 'new'
    name = @project_name
    config = Tmuxinator::Config.project(name)

    unless Tmuxinator::Config.exists?(name)
      template = File.join(File.dirname(File.expand_path(__FILE__)), "../lib/sesh/assets/sample.yml")
      erb  = Erubis::Eruby.new(File.read(template)).result(binding)
      File.open(config, "w") { |f| f.write(erb) }
    end

    Kernel.system("#{get_editor} #{config}") || Tmuxinator::Cli.new.doctor
    puts
  when 'edit'
    config = Tmuxinator::Config.project(@project_name)
    if Tmuxinator::Config.exists? @project_name
      Kernel.system("#{get_editor} #{config}") || Tmuxinator::Cli.new.doctor
      puts
    else
      fatal "Sesh project '#{@project_name}' does not exist yet!"
    end
  when 'list'
    output = format_and_run_command <<-BASH
      ps aux | grep tmux | grep "env TMUX='' mux start" \
             | grep -v "[g]rep" | sed -e "s/.*mux start \\(.*\\)/\\1/"
    BASH
    running_projects = output.split("\n")
    pcount = running_projects.count
    if pcount > 0
      puts "#{pcount} project#{pcount>1 ? 's':''} currently running:"
      puts running_projects
      puts
    else
      fatal "There are no Sesh projects currently running."
    end
  when 'connect'
    addr = @remote_address
    if (is_local=@remote_address.nil?)
      addr = @local_ssh_addr
      fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    end
    command = enter_slave_mode_command(is_local, addr)
    puts `#{command}`.strip
  when 'enslave'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    fatal("You must specify a machine to enslave! Eg: user@ip") if @remote_address.nil?
    debug "Attempting to connect #{@remote_address} to Sesh project '#{@project_name}'..."
    # ssh #{@remote_address} "#{enter_slave_mode_command.gsub(/([^\\])"/, '\1\\"')}"
    # puts <<-BASH
    output = format_and_run_command <<-BASH
      ssh #{@remote_address} "sesh connect #{@project_name} #{@local_ssh_addr}" 
    BASH
  #  1>/dev/null 2>&1 &
    puts output
    if $?
      debug "Sesh client connected successfully."
      puts
    else
      fatal 'Sesh client failed to start.'
    end
  else
    fatal "Command not recognized!"
  end
  exit 0
end

fatal 'You must specify a command.'
