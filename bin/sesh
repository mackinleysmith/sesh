#!/usr/bin/env ruby
require 'tmuxinator'

if ARGV.empty? or ARGV.include? '-h' or ARGV.include? '--help' then puts <<-HELP
Sesh: remote background sessions powered by tmux and tmuxinator.
Runs a headless tmuxinator session for remote slave machines to connect to.

Usage: #{File.basename $0} command [project]

Commands:

sesh new                          Create a new tmuxinator configuration.
sesh start [project]              Start a Sesh session for a project.
sesh stop  [project]              Stop a Sesh session for a project.
sesh list                         List running Sesh sessions on this machine.
sesh connect [project] user@host  Connect as a slave to a remote Sesh session.
sesh enslave [project] user@host  Connect a slave to a local Sesh session.

Leave project blank to use the name of your current directory.

HELP
exit; end

def warn(msg) $stderr.puts msg end
def fatal(msg) $stderr.puts msg; $stderr.puts; exit 1 end
def debug(msg) $stderr.puts "> #{msg}" end

@command = ARGV[0]
@options = ARGV[1..-1] || []
# debug("Options received: #{@options}") if @options.any?

def is_tmuxinator_project?(name)
  path = File.expand_path("~/.tmuxinator/#{name}.yml")
  File.exist? path
end

def get_project_name
  new_project = @command == 'new'
  if @options.any? && !@options[0].include?('@')
    return @options.shift if new_project || is_tmuxinator_project?(@options[0])
  end
  output = `printf '%q\n' "${PWD##*/}"`.strip
  return output if new_project || is_tmuxinator_project?(output)
  puts "Sesh project '#{output}' could not be found."
  fatal "Hint: run sesh new or specify an existing project after your commmand."
end
@project_name = get_project_name

def get_local_username
  `echo $USER`.strip
end
def get_local_hostname
  `scutil --get LocalHostName`.strip.downcase + '.local'
end
@local_ssh_addr = "#{get_local_username}@#{get_local_hostname}"

@socket = "/tmp/#{@project_name}.sock"

def get_remote_address
  @options[@options.length>1 ? 1:0] if @options.any?
end
@remote_address = get_remote_address

def get_term_app
  output = `osascript -e 'try' -e 'get exists application "iTerm"' -e 'end try'`.strip
  output.length > 0 ? 'iTerm' : fatal("iTerm 2 is not installed.") # 'Terminal'
end

def project_name_matcher
  pn = @project_name.gsub '-', '\-'
  "[t]mux.*[#{pn[0]}]#{pn[1..-1]}"
end

def already_running?
  output = `ps aux | grep "#{project_name_matcher}"`.strip
  output.length > 0
end

def format_command(command) command.gsub(/\ [ ]+/, ' ').strip end
def format_and_run_command(command) `#{format_command(command)}`.strip end

def issue_server_start_command!
  `tmux -S "#{@socket}" new-session -d "env TMUX='' mux start #{@project_name}"`
end

def issue_server_stop_command!
  `pkill -f "#{project_name_matcher}"`
end

def connection_command(local=false)
  local_command = "tmux -S #{@socket} a"
  return local_command if local
  "ssh #{@local_ssh_addr} -t '#{local_command}'"
end

def enter_slave_mode_command(local=false)
  @term_app ||= get_term_app
  case @term_app
  when 'iTerm'
    tell_term_app     = 'tell application "' + @term_app + '"'
    tell_term_process = 'tell application "System Events" to tell process "' + 
                         @term_app + '"'
    format_command <<-BASH
      osascript \
            -e '#{tell_term_app} to activate' \
            -e '#{tell_term_process} to keystroke \"n\" using command down' \
            -e 'delay 1' \
            -e "#{tell_term_app.gsub('"', '\\"')} to tell session -1 of current \
                terminal to write text \\"#{connection_command(local)}\\"" \
            -e '#{tell_term_process} to keystroke return using command down'
    BASH
  when 'Terminal'
    format_command connection_command(local)
  end
end

def show_progress_until(condition_lambda, timeout=10)
  started_progress_at = Time.now
  return true if condition_lambda.call
  print '> '
  until condition_lambda.call or Time.now - started_progress_at > timeout
    print '.'
    $stdout.flush
    sleep 0.5 
  end
  puts
  return condition_lambda.call
end

if @command
  case @command
  when 'start'
    fatal("Sesh project '#{@project_name}' is already running!") if already_running?
    debug "Starting Sesh project '#{@project_name}'..."
    output = issue_server_start_command!
    success = show_progress_until ->{ already_running? }
    if success
      sleep 1
      if $? && already_running?
        debug 'Sesh started successfully.'
        debug "To connect: #{connection_command}"
        puts
      else
        fatal 'Sesh failed to start!'
      end
    else
      fatal 'Sesh failed to start after ten seconds!'
    end
  when 'stop'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    debug "Stopping Sesh project '#{@project_name}'..."
    output = issue_server_stop_command!
    success = show_progress_until ->{ !already_running? }
    if success && $?
      debug 'Sesh stopped successfully.'
      puts
    else
      fatal 'Sesh failed to stop after ten seconds!'
    end
  when 'restart'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    puts `sesh stop #{@project_name} #{@options if @options.any?}`.strip
    sleep(0.5)
    puts `sesh start #{@project_name} #{@options if @options.any?}`.strip
  when 'new'
    name = @project_name
    config = Tmuxinator::Config.project(name)

    unless Tmuxinator::Config.exists?(name)
      template = File.join(File.dirname(File.expand_path(__FILE__)), "../lib/sesh/assets/sample.yml")
      erb  = Erubis::Eruby.new(File.read(template)).result(binding)
      File.open(config, "w") { |f| f.write(erb) }
    end

    editor = `echo $EDITOR`.strip
    editor = 'vim' unless editor.length > 0
    Kernel.system("#{editor} #{config}") || Tmuxinator::Cli.new.doctor
    # command = "env EDITOR='vim' tmuxinator new #{@project_name}"
    # output = exec command
    puts
  when 'list'
    output = format_and_run_command <<-BASH
      ps aux | grep tmux | grep "env TMUX='' mux start" \
             | grep -v "[g]rep" | sed -e "s/.*mux start \\(.*\\)/\\1/"
    BASH
    running_projects = output.split("\n")
    pcount = running_projects.count
    if pcount > 0
      puts "#{pcount} project#{pcount>1 ? 's':''} currently running:"
      puts running_projects
      puts
    else
      fatal "There are no Sesh projects currently running."
    end
  when 'connect'
    if (is_local=@remote_address.nil?)
      @remote_address = @local_ssh_addr
      fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    end
    command = enter_slave_mode_command(is_local)
    puts `#{command}`.strip
  when 'enslave'
    fatal("Sesh project '#{@project_name}' is not running!") unless already_running?
    fatal("You must specify a machine to enslave! Eg: user@ip") if @remote_address.nil?
    debug "Attempting to connect #{@remote_address} to Sesh project '#{@project_name}'..."
      # ssh #{@remote_address} "#{enter_slave_mode_command.gsub(/([^\\])"/, '\1\\"')}"
    output = format_and_run_command <<-BASH
      #{enter_slave_mode_command} | ssh -T #{@remote_address} 1>/dev/null 2>&1 &
    BASH
    puts output
    if $?
      debug "Sesh client connected successfully."
      puts
    else
      fatal 'Sesh client failed to start.'
    end
  else
    fatal "Command not recognized!"
  end
  exit 0
end

fatal 'You must specify a command.'
